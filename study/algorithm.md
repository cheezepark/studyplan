# CS50(2019)

**4. 알고리즘**

*배열이 정렬되어 있는지 여부에 따라,*

- 선형 검색

    처음부터 끝까지 인덱스 하나씩 방문하여 그 값에 속하는지 검사하는 방법

    O(n), Ω(1)

- 이진 검색

    만약 배열이 정렬되어 있다면, 배열 중간 인덱스부터 시작하여 찾고자 하는 값과 비교해 그보다 작은, 혹은 큰 인덱스로 이동하면 됨

    O(log n), Ω(1)

상한 시간(big-O)과 하한 시간의 뜻은 상한은 최악의 경우, 하한은 최선의 경우라고 생각하면 이해가 쉽다

*정렬되지 않은 리스트 탐색보다 정렬한 뒤의 탐색하는 것이 효율적*

**정렬 알고리즘**

- 버블 정렬

    두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬하는 방식

    접근법은 간단하지만 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비 발생할 수 있다

    중첩 루프를 돌아야 하고, n개의 값이 주어졌을 때 각 루프는 각각 n-1번, n-2번 반복되므로 (n-1)(n-2)=n^2 - 3n + 2 번의 비교 및 교환이 필요하다

    여기서 가장 크기가 큰 요소는 n^2 이므로 위와 같은 코드로 작성한 버블 정렬 실행 시간의 상한은 O(n^2)이라고 할 수 있다

    정렬이 되어 있는지 여부에 관계 없이 루프를 돌며 비교를 해야 하므로 상한과 하한이 같다 (Ω(n^2))

- 선택 정렬

    배열 안의 자료 중 가장 작은 수 혹은 가장 큰 수를 찾아 첫 번째 위치 혹은 마지막 위치의 수와 교환해 주는 방식

    교환 횟수는 최소화하는 반면 각 자료를 비교하는 횟수는 증가

    소요 시간의 상한은 O(n^2), 하한은 Ω(n^2)이므로 상한과 하한이 동일

- 병합 정렬

    원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬을 하는 방식

    병합 정렬 실행 시간의 상한은 O(n log n)이다

    숫자들을 반으로 나누는 데에 O(log n)의 시간이 들고, 각 반으로 나눈 부분들을 다시 정렬해서 병합하는 데 각각 O(n)이 걸리기 때문이다

    이미 정렬되어 있는지 여부에 관계 없이 나누고 병합하는 과정이 필요하기 때문에 하한 역시 같다